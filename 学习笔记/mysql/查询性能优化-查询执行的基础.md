# 查询执行的基础

 ![](/img/屏幕截图%202022-05-05%20205834.png)

1. 客户端大宋一条查询给服务器
2. 服务器先检查缓存，如果命中缓存直接返回，否则进入下一阶段
3. 服务器惊醒sql解析优化、预处理、再由优化器生成对应的执行计划
4. Mysql 根据优化器生成的执行计划，调用存储引擎 api 来执行查询
5. 将结果返回给客户端
   
<br>

## mysql 客户端/服务端通信协议

<br>

   Mysql 客户端和服务端的通信协议是**半双工**的，这意味着在同一时刻要么有服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不会同时发生。

### 查询状态

对于一个mysql连接或者说一个线程，任何时刻都有一个装填，改状态表示了MYSQL当前正在做什么。最简单使用 **SHOW FULL PROCESSLIST** 命令

1. sleep
    
    线程正在等待客户端发送新的请求
2. query

    线程正在执行查询或正在将结果赶回给服务端
3. Locked

    在mysql的服务层，该线程正在等待表锁。 在存储引擎级别实现的锁，例如 innodb的行锁，并不会体现在线程状态中
4. Abalyzing and statisitcs

    线程正在收集存储引擎信息，并生成查询计划

5. Sorting result

    线程正在对结果集排序

6. Sending data

    表示多中情况： 线程可能在多个状态之间传送数据， 或在生成结果集，或向客户端发送数据

<br>

## 查询缓存

<br>

如果缓存是打开的，在解析一个查询语句之前，mysql 会优先检查这个查询是否命中缓存中的数据，这个检查是通过一对大小写敏感的哈希查找实现的，查询和缓存中的查询即使只有一个字节不同，那么他们也不会匹配缓存结果，这种情况下查询就会进入下一个阶段

如果当前查询恰好命中缓存，那么子啊返回结果时会检查一次用户权限，如果权限没有问题，mysql会跳过其他阶段，从缓存中得到结果并返回给客户端

<br>

## 查询优化处理

<br>

将一个 sql  解析成一个执行计划，mysql 按照这个执行计划和存储引擎交互，这包含多个子阶段： 解析 sql、预处理、优化 sql 执行计划

### 语法解析器和预处理

mysql 通过关键字将 sql 语句进行解析 ，并生成一个对应的 “ 解析树 ”， Mysql 解析器将使用mysql 语法规则验证和解析查询。 例如： 是都使用错误的关键字、使用关键字的顺序是否正确、 验证引号使用

预处理器则根据一些mysql 规则进一步检查解析树是否合法，例如：检查表列是否存在，解析名字和别名

### 查询优化器

优化器 解析树 转化成执行计划，一条查询可以有很多种执行方式，优化器就是为了找到最好的执行方式。

mysql使用的是基于成本的优化器，他将尝试预测一个查询使用某种执行计划时的成本，并选择成本最小的哪一个。

可以通过 **Last_query_cost** 的值来的值Mysql计算的当前查询成本

有很多原因会导致Mysql 优化器选择错误的执行计划
* 统计信息不准确。Mysql 以来存储引擎提供的统计信息评估成本，但是有的存储引擎提供的信息时准确的，有的偏差可能非常大，例如： innodb 因为其的 mvcc 架构，并不能维护一个数据表的行数的精确统计信息
* 执行计划中的成本估算不等同于实际执行成本
* mysql 只是基于成本模型选择最优的执行计划，而有些却并不是最快的执行方式
* 如果存在全文搜索的 MATCH() 子句，则在存在全文索引是使用全文索引，即使有时候使用别的索引和 where 条件更快，MYSQL依然会使用全文索引
* Mysql 不会烤炉不受其控制的操作额成本，例如存储过程或者自定义函数
* 优化器有时无法估算所有可能的执行计划

优化策略可以简单的分成两种
1. 静态优化 ： 直接对解析树进行分析优化 （where 条件转换秤另一种形式）
2. 动态优化 ： 与查询大的上下文有关，也可能和i他因素有关 （where 条件的取值，索引的条目数）

mysql能够处理的优化类型
#### 重新定义关联表的顺序
1. 将外连接转换为内连接
2. 使用等价变换规则

    它可以合并和减少一些比较，还可以移除一些恒成立和一些不恒成立的判断 （5=5 and a > 5 ----- a > 5）
    (a < b and b = c) and a = 5 ------------ b>5 and b=c and a = 5
3. 优化 count（） 、 min（）、max（）

    如果查询列存在索引，只需查询 b-树的最左端 和 最右端 就可以查询出 min、max 优化器会将这个表达式最为一个常数对待

    没有任何 where 的 count（） 查询通常也可以使用存储引擎提供一些优化 （myisam 维护了一个变量来存放数据表的行数）
 4. 预估并转换未常数表达式

    当mysql 检测到一个表达式可以转换为常数时，就会一直把这个表达式作为常数进行优化。有时甚至一个查询也能够转化为一个常数，（在索引列上执行 min 函数），甚至主键和唯一索引也能转换成一个常数。如果where子句中使用了该类索引的常数条件，mysql可以在查询开始阶段就找到这些值，这样优化器就能够知道并转换为常数表达式

5. 索引覆盖扫描

    当索引类中包含所有的查询需要使用的列，MySQL就可以使用索引返回需要的数据

6. 子查询优化

    mysql 在某种情况下镜子查询转换为一种效率更高的形式，从未减少多个查询多次对数据访问 ？？

7. 提前终止查询

    在发现已经满足查询需求的时候，MySQL总能立即终止查询，例如 limit 、 或者发现了一个不成立的条件

    当存储引擎需要检索“不同取值” 或判断存在性时
    ``` sql
    select film.film_id 
    from film
     left outer join actor using(film_id)
     where actor.film_id is null
     类似这种 不同值/不存在 的优化一般可用于 DISTINCT \ NOT EXIST \ left join
    ```
8. 等值传播

   如果两个列的值通过等式关联，那么mysql 能够吧其中一个列的值传播到另一列上

   ```sql
        select film.film_id 
            from film
            left outer join actor using(film_id)
         where actor.film_id > 500
         这里使用 film_id 进行了等值关联，where子句不仅适用 film 表 也适用 actor 表
   ```    
9. 列表 in 比较

    在mysql 中IN() 不等同于 or Mysql 会将in（） 列表中的数据进行排序，然后通过二分查找的方式来确定类表中的类是否满足条件，这是一个 O（log n）复杂度的操作，等价的转换成or 查询的复杂度为 O（n）
，对于 in 列表中有大量取值时，mysql的处理会更快














