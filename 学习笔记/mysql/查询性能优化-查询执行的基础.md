# 查询执行的基础

 ![](/img/屏幕截图%202022-05-05%20205834.png)

1. 客户端大宋一条查询给服务器
2. 服务器先检查缓存，如果命中缓存直接返回，否则进入下一阶段
3. 服务器惊醒sql解析优化、预处理、再由优化器生成对应的执行计划
4. Mysql 根据优化器生成的执行计划，调用存储引擎 api 来执行查询
5. 将结果返回给客户端
   
<br>

## mysql 客户端/服务端通信协议

<br>

   Mysql 客户端和服务端的通信协议是**半双工**的，这意味着在同一时刻要么有服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不会同时发生。

### 查询状态

对于一个mysql连接或者说一个线程，任何时刻都有一个装填，改状态表示了MYSQL当前正在做什么。最简单使用 **SHOW FULL PROCESSLIST** 命令

1. sleep
    
    线程正在等待客户端发送新的请求
2. query

    线程正在执行查询或正在将结果赶回给服务端
3. Locked

    在mysql的服务层，该线程正在等待表锁。 在存储引擎级别实现的锁，例如 innodb的行锁，并不会体现在线程状态中
4. Abalyzing and statisitcs

    线程正在收集存储引擎信息，并生成查询计划

5. Sorting result

    线程正在对结果集排序

6. Sending data

    表示多中情况： 线程可能在多个状态之间传送数据， 或在生成结果集，或向客户端发送数据

<br>

## 查询缓存

<br>

如果缓存是打开的，在解析一个查询语句之前，mysql 会优先检查这个查询是否命中缓存中的数据，这个检查是通过一对大小写敏感的哈希查找实现的，查询和缓存中的查询即使只有一个字节不同，那么他们也不会匹配缓存结果，这种情况下查询就会进入下一个阶段

如果当前查询恰好命中缓存，那么子啊返回结果时会检查一次用户权限，如果权限没有问题，mysql会跳过其他阶段，从缓存中得到结果并返回给客户端

<br>

## 查询优化处理

<br>

将一个 sql  解析成一个执行计划，mysql 按照这个执行计划和存储引擎交互，这包含多个子阶段： 解析 sql、预处理、优化 sql 执行计划

### 语法解析器和预处理

mysql 通过关键字将 sql 语句进行解析 ，并生成一个对应的 “ 解析树 ”， Mysql 解析器将使用mysql 语法规则验证和解析查询。 例如： 是都使用错误的关键字、使用关键字的顺序是否正确、 验证引号使用

预处理器则根据一些mysql 规则进一步检查解析树是否合法，例如：检查表列是否存在，解析名字和别名

### 查询优化器

优化器 解析树 转化成执行计划，一条查询可以有很多种执行方式，优化器就是为了找到最好的执行方式。

mysql使用的是基于成本的优化器，他将尝试预测一个查询使用某种执行计划时的成本，并选择成本最小的哪一个。

可以通过 **Last_query_cost** 的值来的值Mysql计算的当前查询成本

有很多原因会导致Mysql 优化器选择错误的执行计划
* 统计信息不准确。Mysql 以来存储引擎提供的统计信息评估成本，但是有的存储引擎提供的信息时准确的，有的偏差可能非常大，例如： innodb 因为其的 mvcc 架构，并不能维护一个数据表的行数的精确统计信息
* 执行计划中的成本估算不等同于实际执行成本
* mysql 只是基于成本模型选择最优的执行计划，而有些却并不是最快的执行方式
* 如果存在全文搜索的 MATCH() 子句，则在存在全文索引是使用全文索引，即使有时候使用别的索引和 where 条件更快，MYSQL依然会使用全文索引
* Mysql 不会烤炉不受其控制的操作额成本，例如存储过程或者自定义函数
* 优化器有时无法估算所有可能的执行计划

优化策略可以简单的分成两种
1. 静态优化 ： 直接对解析树进行分析优化 （where 条件转换秤另一种形式）
2. 动态优化 ： 与查询大的上下文有关，也可能和i他因素有关 （where 条件的取值，索引的条目数）

mysql能够处理的优化类型
#### 重新定义关联表的顺序
1. 将外连接转换为内连接
2. 使用等价变换规则

    它可以合并和减少一些比较，还可以移除一些恒成立和一些不恒成立的判断 （5=5 and a > 5 ----- a > 5）
    (a < b and b = c) and a = 5 ------------ b>5 and b=c and a = 5
3. 优化 count（） 、 min（）、max（）

    如果查询列存在索引，只需查询 b-树的最左端 和 最右端 就可以查询出 min、max 优化器会将这个表达式最为一个常数对待

    没有任何 where 的 count（） 查询通常也可以使用存储引擎提供一些优化 （myisam 维护了一个变量来存放数据表的行数）
 4. 预估并转换未常数表达式

    当mysql 检测到一个表达式可以转换为常数时，就会一直把这个表达式作为常数进行优化。有时甚至一个查询也能够转化为一个常数，（在索引列上执行 min 函数），甚至主键和唯一索引也能转换成一个常数。如果where子句中使用了该类索引的常数条件，mysql可以在查询开始阶段就找到这些值，这样优化器就能够知道并转换为常数表达式

5. 索引覆盖扫描

    当索引类中包含所有的查询需要使用的列，MySQL就可以使用索引返回需要的数据

6. 子查询优化

    mysql 在某种情况下镜子查询转换为一种效率更高的形式，从未减少多个查询多次对数据访问 ？？

7. 提前终止查询

    在发现已经满足查询需求的时候，MySQL总能立即终止查询，例如 limit 、 或者发现了一个不成立的条件

    当存储引擎需要检索“不同取值” 或判断存在性时
    ``` sql
    select film.film_id 
    from film
     left outer join actor using(film_id)
     where actor.film_id is null
     类似这种 不同值/不存在 的优化一般可用于 DISTINCT \ NOT EXIST \ left join
    ```
8. 等值传播

   如果两个列的值通过等式关联，那么mysql 能够吧其中一个列的值传播到另一列上

   ```sql
        select film.film_id 
            from film
            left outer join actor using(film_id)
         where actor.film_id > 500
         这里使用 film_id 进行了等值关联，where子句不仅适用 film 表 也适用 actor 表
   ```    
9. 列表 in 比较

    在mysql 中IN() 不等同于 or Mysql 会将in（） 列表中的数据进行排序，然后通过二分查找的方式来确定类表中的类是否满足条件，这是一个 O（log n）复杂度的操作，等价的转换成or 查询的复杂度为 O（n）
，对于 in 列表中有大量取值时，mysql的处理会更快

### 数据和索引统计信息

在服务层的查询优化器，没有保存数据和索引的统计信息，统计信息由存储引擎实现，不通的存储引擎可能会存储不通的统计信息， Mysql在生成执行计划时，需要向存储引擎获取相应的统计信息。存储引擎则提供给优化器对应的统计信息，包括：每个表或者索引有几个页面，每个表每个索引的技术是多少、数据行和索引的长度、索引的分布信息等。优化器根据这些信息选择一个最优的执行计划。

### mysql如何实现关联查询

在mysql中，每一个查询、每一个片段（包括子查询，甚至单表的select）都有可能关联

对于UNION 查询 ， MYSQL 先将一系列查询放到临时表中，然后在重新读取临时表数据来完成 union 查询，在mysql的概念中，每一次查询都是一次关联查询，所以读取临时表也是一种关联查询

Mysql 对任何的关联查询都是执行**嵌套循环**关联操作，即 Mysql 会先在一张表中循环取出单条数据，然会在嵌套循环关联操作，一次下去，直到找到表中匹配的行位置，然后根据各个表中匹配到的行，返回查询中需要的各个列，mysql 会尝试在最后一个关联表中找到匹配的行，如果最后一个关联表无法找到更多的行以后，Mysql返回到上一层次关联表，看是否能够找到更多的匹配记录，以此类推迭代执行。

**嵌套关联查询** 查找第一个表中的记录，再嵌套查询下一个关联表，然后回溯到上一个表

 ```sql
    select tbl1.col1,tbl2.col2
    from tbl1 left join tbl2 using(col3)
    where tbl1.col1 in (5,6)
 ```
 ![](/img/屏幕截图%202022-05-16%20191806.png)

 Mysql 对于所有类型的存续都以同样的方式运行，例如 Mysql在 from 子句中遇到子查询时，先执行子查询并将结果放到一个临时表中，让后将临时表当作普通表对待。 mysql union 查询时也使用类似的临时表，在遇到右连接时，Mysql将其改写成等价的左外连接。

 > 全外连接无法通过嵌套循环和回溯的方式完成，mysql 不支持全外连接。。。

 ### 执行计划

 mysql 生成查询的一颗指令书，然后通过存储引擎执行完成这棵指令书并返回结果，最终的执行计划包好了重构查询全部信息，如果对某个查询执行 explain rxrended ，在执行show warnings 就可以看到重构出的查询。

多表联查的一种方式
 ![](/img/屏幕截图%202022-05-16%20193016.png)

MySQL总是从第一个表开始一直嵌套循环、回溯完成所有表的关联。


 ![](/img/屏幕截图%202022-05-16%20193311.png)


 ### 关联查询优化器

 mysql 最重要的一部分就是关联查询优化，它决定了多表关联的顺序。通常多张表关联的时候。可以有多种不通的关联顺序来获取相同的结果。关联查询优化器则通过评估不同顺序时的成选择一个代价最小的关联顺序。

 **倒转的关联顺序会让查询进行更少的嵌套循环和回溯操作**

 关联优化器会尝试在所有的关联顺序中选择一个成本最小的来生成执行计划树，如果可能，优化器会遍历每一个表然后逐个做嵌套循环计算每一棵树可能的执行计划树的成本，最后返回最优的执行计划。
 当有超过 N 个表的关联，那么需要检查 N 的阶乘中关联顺序，我们称之为所有可能的执行计划的**搜索空间**
若有十个表关联，查询空间非常大，优化器选择使用**贪婪**搜索的方式查找最优的关联顺序，实际上，当需要关联的表超过 optimizer_search_depth的限制的时候就会选择贪婪搜索模式了

### 排序优化

如果排序的数据量小于‘排序缓冲区’，mysql则使用内存进行**快速排序操作，如果内存不够排序，那么mysql会将数据分矿，对每个独立的块使用快速排序进行排序，并将各个快速排序结果存放在磁盘上，然后将各个排好序的块进行合并最后返回排序结果

mysql有两种排序算法：
1. 两次传输排序（旧版本使用）

    读取行指针和需要排的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。
    这需要进行两次数据传输，需要从数据表中读取两次数据，第二次读取数据时候，因为时读取排序列进行排序后的所有记录，会产生大量的i/o，所以两次传输排序成本很高，不过这样做的优点是，在排序的时候存储尽可能少的数据，这就让”排序缓冲区“尽可能容纳更多的行进行排序

2. 单次传输排序（新版本使用）

    先读取所需的所有列，然后根据给定列进行排序，最后直接返回排序结果，因为不再需要读取两次数据，对于 i/o密集型的应用，这样做的效率搞了许多，另外，相比两次顺序传输，这个算法只需要一次顺序i/o读取数据，缺点是如果需要返回的列很多，会儿外占用大量的空间，而这些列堆排序并没有任何作用，因为单挑排序记录很大没所以可能会有更多的排序快需要合并

mysql在进行文件排序的时候需要使用的临时存储空间可能会比想象的大得多。原因在于mysql在排序时，对每一个排序记录都会分配一个足够长的定长空间来存放。

在关联查询的时候如果需要排序，Mysql会分为两种情况来处理文件排序。如 order by 的字段都来自于关联的一个表，那么mysql在关联处理第一个表时就进行文件排序，除此之外 mysql都回先将关联的结果存放在临时表中，然后在所有的关联都结束后，再进行文件排序。如果有limit  ， limit也会就在排序之后应用。

## 查询执行引擎

在解析和优化阶段，mysql将生成对应的执行嘉华， mysql 的查询及执行引擎则根据这个执行计划来完成整个查询，这里执行嘉华是一个数据结构，为不是和很多其他的关系型数据库那样生成对应的字节码

查询执行阶段，只是简单的根据执行计划给出的执行进行执行没在查询过程中，有大量的操作需要通过调用存储引擎来完成，这些接口也就是我们成为**handler api**的接口，查询中每一个表由一个hanlder 的实例来表示，优化器根据这些实例的接口可以获取表相关的信息，包括列明、索引统计信息等等。

存储引擎接口有非常丰富的功能，但是底层接口只有几十个，这些接口像搭积木一样能够完成大部分操作，

**为了执行查询，mysql只需要重复执行计划中的哥哥操作，知道完成所有的数据查询。**

## 返回给客户端

即使查询不需要返回结果集给客户端，mysql仍然会返回这个查询的一些信息，如该查询影响到的行数。

如果查询可以被缓存，那么mysql在这个阶段也会将结果存放到缓存中。

mysql将结果集返回是一个增量、逐步返回的过程，例如，关联查询处理完最有一个关联表，开始生成第一条结果时，mysql就可以开箱向客户端逐步返回结果集了





