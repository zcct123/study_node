# 分区表

分区表是一个独立的逻辑表，但是底层有多个物理子表组成。实现分区表的代码实际上是对一组底层表的句柄对象的封装。对分区表的请求，都会通过句柄对象转化成存储引擎的接口调用。 分区表对 sql 来说是一个完全封装实现的黑盒子，每一个分区表都有一个使用 # 分隔明明的表文件

mysql 实现分区表的方式——对底层表的封装——意味着索引也是按照分区的子表定义的，而没有全局索引

mysql在创建表时手机用 RARTITION BY 子句定义每一个分区存放的数据，在执行查询的时候，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询就无需扫描所有分区。


分区表本身的限制
* 一个表最多有1024个分区、
* 在mysql5.1中分区表达式必须是整数，或者返回整数的表达式。在mysql5.5中某些长江可以直接使用列来进行分区。
* 如果分区字段中有著就按或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来
* 分区表无法使用外键约束

## 原理

1. select 查询

    当插入一个分区表时，分区表先打开并锁住所有底层表，优化器判断是否可以过滤部分分区，然后调用对应的存储引擎接口访问各个分区的数据

2. insert操作

    当写入一条记录时，分区表先打开并锁住所有底层表，然后定位哪个分区接收这条记录，在将记录写入对应的底层表

3. delete操作

    当删除一条记录时，分区表先打开并锁住所有底层表，然后确定数据对应的分区，左后对相应底层表进行删除操作

4. update操作

    当更新一条记录时，分区表先打开并锁住所有底层表，先确认需要更新的数据在哪一个分区，然后取出数据并更新，在判断更新后的数据应该放在哪一个分区，最后对底层表进行接入操作，并对源数据进行删除操作

虽然每一个操作都会 **先打开并锁住所有底层表** ，但这并不是说分区表在处理过程中时锁住全表的，如果存储引擎能够实现行级锁，则会在分区曾释放对应的表锁

## 分区的类型

* RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区。
* LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。
* HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。
* KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL 服务器提供其自身的哈希函数。必须有一列或多列包含整数值。


## 使用分区表
1. 全量扫描数据，不要任何索引

    只要 where 条件、将需要的数据限制在少数分区中，效率很高，适用于以正常方式访问大量数据

2. 索引数据并分离热点

    如果数据由明显的热点，而且除了这部分数据，其他数据很少被访问到，可以将热点数据放在一个单独的分区，让这个分区的数据能够有机会放在内存中，这样查询就可以访问一个很小的表

## 可能出现的问题

    1. NULL 值会使分区过滤无效

        假设按照 RARTITION BY RANGE YEAR(order_date) 分区，那么所有order_date 为 null 或者是一个非法值额时候，记录都会被存到第一个分区， 假设通过 order_date > 2012-01-01 and < 2012-05-05查询，实际上它会检查两个分区，而不是只检查2012这一个分区
    
    2. 分区列和索引列不匹配

        如果定义索引列和分区列不匹配，会导致查询无法进行分区过滤。假设在列A上定义了索引，而在列B上进行了分区。因为每个分区都是独立的索引，所以扫描列B上的索引就需要扫描每一个分区内对应的索引，要避免这个问题提，因该避免建立和分区列不匹配的索引，除非查询中同时还包含可以过率分区的条件

    3. 选择分区的成本很高

        键分区和哈希分区没有这个问题，范围分区服务器会扫面所有分区定义的列表来确认‘这一行属于哪一个分区’，如果一次插入很多数据时则每次写入一行数据都需要扫描

    4. 打开并锁住所有底层表的成本会很高

        这个操作在分区过滤之前发生，这对一些本身很快的查询会明显带来额外卡西奥

    5. 维护分区的成本可能很高

        例如重组分区






