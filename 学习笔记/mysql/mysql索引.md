# mysql 索引

## 索引的数据结构

### 1. B+Tree索引
B+Tree 通常意味着所有的值是按照顺序存储的，并且每一个叶子节点到根的距离相等

 ![](/img/屏幕截图%202022-02-28%20193632.png)

 >B+数索引能够加快数据的访问速度，因为存储引擎不需要进行全表扫描，只需要从索引的根节点触发开始进行搜索，存储引擎根据这些指针向下层查找，通过比较节点页的值，和要查找的值找到合适的指针进入到下层节点。这些指针实际定义了子节点的上限和下限。最终存储引擎要么找到了值，要么值不存在。

 </br>

 #### InnoDB一棵B+树可以存放2千万行数据
 
 </br>

 * 在计算机中，磁盘存储数据最小单元是扇区，一个扇区的大小是512字节
 * 文件系统中，最小单位是块，一个块大小就是4k
 * InnoDB存储引擎最小储存单元是页，一页大小就是16k
 ![](/img/屏幕截图%202022-02-28%20194455.png)
   >假设B+树的高度为2的话，即有一个根结点和若干个叶子结点。这棵B+树的存放总记录数为= 根结点指针数 * 单个叶子节点记录行数。
   如果一行记录的数据大小为1k，那么单个叶子节点可以存的记录数 =16k/1k =16.
非叶子节点内存放多少指针呢?我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，所以就是8+6=14字节，16k/14B =16*1024B/14B = 1170.   因此，一棵高度为2的B+树，能存放1170 * 16=18720条这样的数据记录。同理一棵高度为3的B+树，能存放1170 *1170 *16 =21902400，也就是说，可以存放两千万左右的记录。B+树高度一般为1-3层，已经满足千万级别的数据存储。

 </br>

 #### 索引结构默认使用B+树，而不是B-Tree，Hash哈希，二叉树，红黑树

 </br>

 * Hash哈希，只适合等值查询，不适合范围查询
 * 一般二叉树，可能会特殊化为一个链表，相当于全表扫描 二叉树深度很高
 * 红黑树，是一种特化的平衡二叉树，MySQL 数据量很大的时候，索引的体积也会很大，内存放不下的而从磁盘读取，树的层次太高的话，读取磁盘的次数就多了
 * B-Tree，叶子节点和非叶子节点都保存数据，相同的数据量，B+树更矮壮，也是就说，相同的数据量，B+树数据结构，查询磁盘的次数会更少。
 * 
 </br>

#### 可以使用 B+Tree索引的查询类型

 </br>

1. 全值匹配：因为树是有序的
2. 匹配列前缀：树相对于最左字符串是有序的
3. 匹配范围值：在范围内列是有序的
4. 精准匹配某一列或范围匹配另一列：多个列索引
5. 只访问索引列的查询：索引覆盖

</br>

#### B+Tree索引失效的一些场景

</br>

**根本原因是查询索引无序了**
1. OR查询左右有未命中索引的；
2. 复合索引不满足最左匹配原则；
3. Like以%开头；
4. 需要类型转换；
5. where中索引列有运算；
6. where中索引列使用了函数；
7. 如果mysql觉得全表扫描更快时（数据少时）

</br>

### 1. Hash索引

</br>

Hash索引 是基于哈希表实现的，只有精确匹配索引所有列查询菜有效。对于每一列数据，存储引擎都回对所有的索引列计算一个HASH码，哈希索引将所有的哈希码存储到索引中，同时保存这一行数据的指针。 

**多个列哈希值相同，索引会一链表的形式存放多个记录指针到同一个哈希条目中**

</br>

#### Hash索引的限制

</br>

* 只存储指针，不存储字段，无法避免读取行
* 哈希索引无序，无法排序和范围查找
* 不支持索引列匹配查找
* 只支持等值，包括 in ， = ,<=>
* 哈希冲突比较多时，维护索引代价比较高

</br>

### 3. 空间数据索引（R-Tree） 

</br>

MyISAM 表支持空间索引，可以用作地理位置存储，这类索引无序前缀查询，mysql的GIS并不完善

</br>

### 4. 全文索引

</br>

全文索引是一种特殊的索引，他查找的时文本的中关键词，而不是索引中的值，全文索引适用于MATCH AGAINST操作


## 创建高性能索引

### 1. 前缀索引和索引的选择性

</br>

有些时候索引需要很长的字符串，通常可以索引开始的部分字符，以节约索引空间，但同时这样也降低了索引的选择性， **索引的选择性 = 不重复的索引（基数）/ 数据表的记录数（#T）, 当比值为 1 时代表这是最好的索引。

</br>

例子：
``` sql
    select count( distinct name) / count(*) from city
    ## 完整列的选择性，假设这个值为0.0312
    select count( distinct left(name,3)) / count(*)
            count( distinct left(name,4)) / count(*)
            count( distinct left(name,5)) / count(*)
            count( distinct left(name,6)) / count(*) 
            count( distinct left(name,7)) / count(*) 
            count( distinct left(name,8)) / count(*) 
    ## 假设计算输出 left7 为 0.031 left8 为 0.0311
    ## 当前缀到达7的时候，再增加前缀，选择性上升很小，而且接近于完整列的选择性        

```

</br>

### 2. 多列索引

</br>


在多个列上建立独立的单列索引大部分情况下并不会提高Mysql的查询性能，Mysql5.0版本引入了**索引合并**的策略，可以使用多个**单列索引**来定位指定的行。

</br>

索引合并：
* 当服务器对多个索引做相交操作时，（多个and），通常意味着需要包含所有相关列的多列索引，而不是独立的单独索引
* 服务器对多个多因类做相交联合操作时（多个 or），需要耗费大量的 cpu和内存资源在算法的缓存、排序、合并操作上

</br>

#### 2.1 选择合适的索引列顺序

</br>

在一个多列B+树索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次第二列，等等。


选择索引列顺序：在不考虑 IO 和排序时 将选择性最高的列放在索引的最前列。（场景不同选择不同）

例子：
``` sql
    select * from payment where staff_id = 2 and customer_id = 584

    # 对于这个查询取建立索引可以先预测一下这个表中两个值的分布情况

    select sum(staff_id = 2) , sum(customer_id = 584) from payment 

    #  sum(staff_id = 2) ： 7756   sum(customer_id = 584) ： 30
    #  依据选择性最高的列放在前面 customer_id 的选择性最高

    # 对于 customer_id 的条件值，对应的 staff_id 的选择性

    select sum(staff_id = 2) where customer_id = 584

    #  sum(staff_id = 2) ：17 选择性也很高

```

但是上边的例子非常依赖于选定的具体值，可能造成查询不公平

``` sql
    select count（distinct staff_id）/count(*),
            count (distinct customer_id)/count(*) from payment
            
    #         staff_id: 0.0001   customer_id: 0.0373
    # customer_id 测选择性高，作为索引的第一列
```

</br>

### 3. 聚簇索引

</br>

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式，当表有聚簇索引时，他的数据行实际上存放在索引的叶子页中。  InnoDB 通过主键聚集数据，也就是说被索引的列是主键列，一些数据库服务器允许选择拿高分索引作为聚簇索引
![](/img/屏幕截图%202022-03-01%20190540.png)

聚集的数据优点：
* 把相关数据保存在一起，磁盘读取少量的数据也就能获取数据
* 数据访问更快。把数据和索引保存在一个B+树中，比非聚簇索引更快
* 使用覆盖索引扫描查询可以直接使用叶节点的主键值

聚簇索引的缺点：
* 聚簇索引最大限度提高了I/O密集型应用的性能，如果数据存在内存中，访问的顺序没那么重要，聚簇索引也就没有优势
* 插入的速度依赖于插入顺序。
* 更新聚簇索引列的代价很高，因为会强制InnoDB 将每个被更新的行移动位置
* 插入新行，或者主键更新，可能面临着 ‘页分裂’。当插入的页已满时，就会把该页分成两个页来保存数据
* 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续
* 二级索引要保存叶子节点要保存的引用行的主键列，索引二级索引比较大
* 二级索引需要两次索引查找（MYISAM（非聚簇）二级索引存储行指针，InnoDB 二级索引存储主键值）

</br>

### 3. 覆盖索引

</br>

如果一个索引包含所有需要查询的列，那么就没有必要回表查询，那么就称之为覆盖索引
优点：
* 索引条目远小于数据行大小，所以只需要读取索引，较少数据访问量
* 索引是顺序存储的，范围查询比随机从磁盘读取某一行I/O要小得多
* 对于InnoDB 避免主键索引的二次查询

例子：
``` sql
    select store_id , film_id from inventory
    # 如果在 store_id , film_id 有意多列多因，extra useing index
```

``` sql
    select * from products where actor = 'SEAN CARREY' and title like '%APOLLO%'
    # 没有任何索引覆盖查询
    # 不能在索引中使用LIKE
    # 这里的关键点在于：提前取出了不需要数据行中的列。 之后丢弃


    #优化：

    # 先将 索引扩展至 三个数据列 （actor ，title ，pro_id）
    select * from products as p
        join (
            select pro_id 
            from products 
            where actor = 'SEAN CARREY' and title like '%APOLLO%'
        ) as t1 on p.pro_id = t1 .pro_id
    # 这种方式叫做延迟关联  「延迟了对列的访问」，不直接获取所有需要的列。
    # 覆盖索引先获取需要的键（一般为主键），再根据取到的键关联原表获得需要的行，这可以减少MYSQL扫描那些不符合条件的行。
    # 如果第一个条件结果集很小子查询带来的成本反而比从表中直接提取完整性要高
```

</br>

### 4. 使用索引扫描进行排序

Mysql 可以使用同意索引技能排序，又用于查找行，设计时尽可能同时满足这两中任务

只有当索引的顺序和 order by 的顺序完全一致，并且所有列的排序方方向都一样时，才能够使用索引来对结果进行排序，如果查询要关联多张表，泽只有order by 自居引用的字段全部为第一个表时，才能使用索引来排序。


在where 或 join 中 当前导列为常数时，索引排序可以不满足最左前缀原则
``` sql
   # 索引列( rental_data, inventory_id, customer_id)
    select id , tip from rental 
    where rental_data = '2022-02-28'  # 索引第一列为被指定为一个常量，这个查询可以利用索引排序
    order by inventory_id, customer_id

# 不能使用索引排序的例子

    # 下面查询使用不同的排序方向
     where rental_data = '2022-02-28'  order by inventory_id DESC, customer_id ASC

    # 引用了不在索引中的列
     where rental_data = '2022-02-28'  order by inventory_id DESC, staff_id ASC

    # 无法组成索引最左前缀
     where rental_data = '2022-02-28'  order by icustomer_id ASC

    # inventory_id列上范围查找
      where rental_data = '2022-02-28' and inventory_id in(1,2)  order by customer_id ASC
```

</br>


### 5. 冗余和重复索引
应该避免创建重复索引 和 未使用的索引
* 主键 和 在主键上加上索引  重复索引
* 索引（A,B） 和 索引 （B） 冗余索引

</br>

### 6. 索引和锁

索引可以让查询锁定更少的行，InnoDB的行锁效率很高，内存也会使用很少，锁定超过需要的行会增加锁征用的并减少并发性

InnoDB只有访问行时才会对其枷锁，而索引能减少访问的行数，从而减少所得数量，

例子：
``` sql
    begin
     select actor_id from actor where actor_id < 5 and actor_d <> 1 for update;
    # 查询返回 [2, 3, 4 ]

    # 这个查询只会返回 2 ~ 4 行的数据，但是时加上获取了 1 ~ 4 行的排他锁，因为改查询的查询计划时范围扫描。

    # 底层存储引擎的操作是 “ 从索引的开头开始获取满足条件  actor_id < 5 的记录,服务器并没有告诉存储引擎可以过滤掉第一行的where条件  执行计划 using where 代表服务器将存储引擎返回行以后在应用 where 过滤条件 
```
这一个例子显示：即使使用了索引，InnoDB 也可能锁住一些不需要的数据，如果不是用索引查找行和锁定行，Mysql就会做全表扫描，并锁住所有的行。

</br>


















